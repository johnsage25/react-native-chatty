{"version":3,"sources":["helpers.ts"],"names":["wait","ms","Promise","resolve","setTimeout","extractUrlFromString","string","regex","match","length","fetchMetaData","url","response","fetch","text","ogImage","RegExp","ogTitle","ogDescription","image","title","description"],"mappings":"AAEA;AACA;AACA;AACA;AACA,OAAO,MAAMA,IAAI,GAAIC,EAAD,IAClB,IAAIC,OAAJ,CAAaC,OAAD,IAAaC,UAAU,CAACD,OAAD,EAAUF,EAAV,CAAnC,CADK;AAGP;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMI,oBAAoB,GAAIC,MAAD,IAAmC;AACrE,QAAMC,KAAK,GACT,qNADF;AAEA,QAAMC,KAAK,GAAGF,MAAM,CAACE,KAAP,CAAaD,KAAb,CAAd;;AAEA,MAAIC,KAAK,IAAIA,KAAK,CAACC,MAAN,GAAe,CAA5B,EAA+B;AAC7B,WAAOD,KAAK,CAAC,CAAD,CAAZ;AACD;;AAED,SAAO,IAAP;AACD,CAVM;AAYP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAME,aAAa,GAAG,MAC3BC,GAD2B,IAEW;AACtC,QAAMC,QAAQ,GAAG,MAAMC,KAAK,CAACF,GAAD,CAA5B;AACA,QAAMG,IAAI,GAAG,MAAMF,QAAQ,CAACE,IAAT,EAAnB;AAEA,QAAMC,OAAO,GAAG,IAAIC,MAAJ,CAAW,gDAAX,CAAhB;AACA,QAAMC,OAAO,GAAG,IAAID,MAAJ,CAAW,gDAAX,CAAhB;AACA,QAAME,aAAa,GAAG,IAAIF,MAAJ,CACpB,sDADoB,CAAtB;AAIA,QAAMG,KAAK,GAAGL,IAAI,CAACN,KAAL,CAAWO,OAAX,CAAd;AACA,QAAMK,KAAK,GAAGN,IAAI,CAACN,KAAL,CAAWS,OAAX,CAAd;AACA,QAAMI,WAAW,GAAGP,IAAI,CAACN,KAAL,CAAWU,aAAX,CAApB;;AAEA,MAAIC,KAAK,IAAIC,KAAT,IAAkBC,WAAtB,EAAmC;AACjC,WAAO;AACLF,MAAAA,KAAK,EAAEA,KAAK,CAAC,CAAD,CADP;AAELC,MAAAA,KAAK,EAAEA,KAAK,CAAC,CAAD,CAFP;AAGLC,MAAAA,WAAW,EAAEA,WAAW,CAAC,CAAD,CAHnB;AAILV,MAAAA;AAJK,KAAP;AAMD;;AAED,SAAO,IAAP;AACD,CA1BM","sourcesContent":["import type { IUrlPreviewBubble } from 'src/types/Chatty.types';\n\n/**\n * `wait` is a function that returns a promise that resolves after a given number of milliseconds\n * @param {number} ms - number\n */\nexport const wait = (ms: number) =>\n  new Promise((resolve) => setTimeout(resolve, ms));\n\n/**\n * It takes a string and returns the first URL found in the string\n * @param {string} string - The string to extract the URL from.\n * @returns The first match of the regex.\n */\nexport const extractUrlFromString = (string: string): string | null => {\n  const regex =\n    /(https?:\\/\\/(?:www\\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\\.[^\\s]{2,}|www\\.[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\\.[^\\s]{2,}|https?:\\/\\/(?:www\\.|(?!www))[a-zA-Z0-9]+\\.[^\\s]{2,}|www\\.[a-zA-Z0-9]+\\.[^\\s]{2,})/gm;\n  const match = string.match(regex);\n\n  if (match && match.length > 0) {\n    return match[0];\n  }\n\n  return null;\n};\n\n/**\n * It takes a URL, fetches the HTML from that URL, and then parses the HTML for the og:image, og:title,\n * and og:description meta tags. If all three of these meta tags are found, it returns a\n * UrlPreviewBubble object with the image, title, and description. If any of these meta tags are\n * missing, it returns null\n * @param {string} url - The URL of the page to fetch.\n * @returns An object with the following properties:\n */\nexport const fetchMetaData = async (\n  url: string\n): Promise<IUrlPreviewBubble | null> => {\n  const response = await fetch(url);\n  const text = await response.text();\n\n  const ogImage = new RegExp('<meta.*property=\"og:image\".*content=\"(.*)\".*/>');\n  const ogTitle = new RegExp('<meta.*property=\"og:title\".*content=\"(.*)\".*/>');\n  const ogDescription = new RegExp(\n    '<meta.*property=\"og:description\".*content=\"(.*)\".*/>'\n  );\n\n  const image = text.match(ogImage);\n  const title = text.match(ogTitle);\n  const description = text.match(ogDescription);\n\n  if (image && title && description) {\n    return {\n      image: image[1],\n      title: title[1],\n      description: description[1],\n      url,\n    };\n  }\n\n  return null;\n};\n"]}